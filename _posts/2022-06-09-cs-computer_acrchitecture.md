---
title: "[CS] Computer Architecture"
excerpt: "Computer Science 1) Computer Architecture"
toc: true
toc_sticky: true
categories:
  - ComputerScience
modified_date: 2020-06-09 10:54:28 +0900
---
# 컴퓨터의 구성 
- 하드웨어 / 소프트웨어로 나뉜다. 


## 소프트웨어 
- 시스템 소프트웨어 : 운영체제, 컴파일러 
- 응용 소프트웨어 : 워드프로세서, 스프레드시트


## 하드웨어
1. 중앙처리장치(CPU)
2. 기억장치 : RAM, HDD
3. 입출력 장치 : 마우스, 프린터 
- 이들은 시스템 버스로 연결되어 있다. 4. 시스템 버스 : 데이터와 명령 제어 신호를 각 장치로 실어나르는 역할 

### 중앙처리장치(CPU)
- 주 기억 장치에서 프로그램 명령어와 데이터를 읽어와 처리하고, 명령어의 수행 순서를 제어함. 
- 중앙처리장치의 구성
  - 산술논리연산장치(ALU) : 비교와 연산
  - 제어장치 : 명령어의 해석과 실행
  - 레지스터 : 속도가 빠른 데이터 기억장소
- 개인용 컴퓨터와 같은 소형 컴퓨터에서는 CPU를 '마이크로프로세서'라고도 부름 

### 기억장치 
- 프로그램, 데이터, 연산의 중간 결과를 저장하는 장치 
- 기억 장치의 구성 
  - 주기억장치 : RAM, ROM. 실행중인 프로그램과 같은 프로그램에 필요한 데이터를 일시적으로 저장 
  - 보조기억장치 : 하드디스크 HDD. 주기억장치에 비해 속도는 느리지만 많은 자료를 영구적으로 보관할 수 있는 장점 

### 입출력장치 
- 입력 장치 : 컴퓨터 내부로 자료를 입력하는 장치 (키보드, 마우스) 
- 출력 장치 : 컴퓨터에서 외부로 표현하는 장치 (프린터, 모니터, 스피커)


## 시스템 버스
- 시스템 버스 : 하드웨어 구성 요소를 물리적으로 연결하는 선 
- 각 구성 요소가 다른 구성 요소로 데이터를 보낼 수 있도록 통로가 되어줌 
- 용도에 따라 데이터 버스, 주소 버스, 제어 버스로 나뉨 
- 컴퓨터는 기본적으로 '읽고 처리한뒤 저장(read->process->write)'하는 과정으로 이루어짐 
  - 이 과정을 진행하면서 끊임없이 주기억장치(RAM)과 소통한다. 이때 운영체제가 64bit면, CPU는 RAM으로부터 데이터를 한번에 64비트씩 읽어옴 

### 데이터 버스 
- 중앙처리 장치와 기타 장치 사이에서 데이터를 전달하는 통로
- '양방향' 버스 : 기억장치, 입출력장치의 명령어와 데이터를 -> 중앙처리장치로 or 중앙처리장치의 연산결과를 -> 기억장치, 입출력장치로. 

### 주소 버스
- 데이터를 정확히 실어나르기 위해서는 기억장치 '주소'를 정해주어야 함 
- '단방향' 버스 : 중앙처리장치가 기억장치 주소를 -> 주기억장치 , 입출력장치로 전달하는 통로 

### 제어 버스 
- 주소 버스와 데이터 버스는 모든 장치에 공유되기 떄문에 이를 제어할 수단이 필요 
- 제어 버스는 중앙처리장치가 제어신호를 -> 기억장치, 입출력장치로 전달하는 통로
- 제어 신호 : 기억장치 읽기 및 쓰기, 버스 요청 및 승인, 인터럽트 요청 및 승인, 클락(1초당 CPU내부에서 몇 단계 작업이 처리되는지), 리셋 
- '양방향' 버스 : 읽기 동작과 쓰기 동작을 모두 수행 

---

# 중앙처리장치(CPU) 작동 원리 
## 중앙 처리 장치의 구성 
### 연산 장치 
- 산술연산과 논리연산수행 (산술논리연산장치) 
- 연산에 필요한 데이터를 레지스터에서 가져오고, 연산결과를 다시 레지스터로 보냄 
### 제어 장치 
- 명령어를 순서대로 실행할 수 있게하는 장치 
- 주기억장치에서 프로그램 명령어를 꺼내 해독하고, 그 결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력장치로 보냄. 
- 이들 장치가 보낸 신호를 받아 다음에 수행할 동작을 결정함. 
### 레지스터 
- 고속 기억장치
- 명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장 
- 용도에 따라 범용 레지스터와 특수목적 레지스터로 구분. CPU 종류에 따라 사용할 수 있는 레지스터 개수나 크기가 다름 
  - 범용 레지스터 : 연산에 필요한 데이터나 연산 결과를 임시로 저장 
  - 특수목적 레지스터 : 특별한 용도로 사용하는 레지스터 

## 특수 목적 레지스터 중 중요한 것들 
- MAR(메모리 주소 레지스터) : 읽기와 쓰기 연산을 수행할 주기억장치 주소 저장 
- PC(프로그램 카운터) : 다음에 수행할 명령어 주소 저장 
- IR(명령어 레지스터) : 현재 실행 중인 명령어 저장 
- MBR(메모리 버퍼 레지스터) : 주기억장치에서 읽어온 데이터 or 저장할 데이터 임시 저장 
- AC(누산기) : 연산 결과 임시 저장 

## CPU의 동작 과정 
1. 주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램 읽어옴 
2. CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억장치에 저장
3. 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 보냄
4. 제어 장치는 1~3 과정에서 명령어가 순서대로 실행되도록 각 장치를 제어 

## 명령어 세트 
### 명령어 세트란 
- 명령어 세트 : CPU가 실행할 명령어의 집합. 연산코드(operation code) + 피연산자(operand)로 이루어짐 
  - 연산코드 : 실행할 연산. 연산, 제어, 데이터 전달, 입출력 기능 
  - 피연산자 : 필요한 데이터 or 저장 위치. 주소, 숫자/문자, 논리데이터 등을 저장 
- CPU는 프로그램 실행하기 위해 주기억장치에서 명령어를 순차적으로 인출하여 해독하고 실행하는 과정을 반복함 
- 명령어 사이클 : CPU가 주기억장치에서 한번에 하나의 명령어를 인출해서 실항하는데 필요한 일련의 활동
  - 명령어 사이클은 인출/실행/간접/인터럽트 사이클로 나누어짐
  - 주기억장치의 지정된 주소에서 하나의 명령어를 가져오고, **실행 사이클**에서는 명령어를 실행함. 하나의 명령어 실행이 완료되면 그 다음 명령어에 대한 **인출 사이클** 시작 

### 인출 사이클 : 명령어 처리 과정 
- 인출 사이클에서 가장 중요한 부분 : PC(프로그램 카운터) 값 중가 
- PC에 저장된 주소를 MAR(메모리 주소 레지스터)로 전달 
- 저장된 내용을 토대로 주기억장치의 해당 주소에서 명령어 인출
- 인출한 명령어를 MBR에 저장
- 다음 명령어를 인출하기 위해 PC 값 증가시킴 
- 메모리 버퍼 레지스터(MBR)에 저장된 내용을 명령어 레지스터(IR)에 전달     
- 인출 과정 
  ```
    T0 : MAR <- PC
    T1 : MBR <- M[MAR], PC <- PC+1
    T2 : IR <- MBR
  ```

### 실행 사이클 : 인출 후 명령어 실행 과정
- ADD addr 명령어 연산 
- 실행 과정 
  ```
    T0 : MAR <- IR(Addr)
    T1 : MBR <- M[MAR]
    T2 : AC <- AC + MBR
  ```
 
 - 이미 인출이 진행되고 명령어만 실행하면 되기 때문에 PC 증가할 필요 x 
 - IR에 MBR의 값이 이미 저장된 상태를 의미함 
 - 따라서 AC에 MBR을 더해주기만 하면 됨

---

# 캐시 메모리
## 캐시 메모리란
- 속도가 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리 
- 예시 
  - CPU 코어와 메모리 사이의 병목 현상 완화 
  - 웹 브라우저 캐시 파일은, 하드디스크와 웹페이지 사이의 병목 현상 완화 
- CPU가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장한 뒤, 다음에 이용할 때 주기억장치가 아닌 캐시메모리에서 먼저 가져오면서 속도를 향상시킴 
- 장점 : 속도 / 단점 : 용량이 적고 비용이 비쌈 

## 캐시 메모리 종류
- CPU에는 이런 캐시메모리가 2~3개 정도 사용된다 (L1, L2, L3 캐시 메모리) 
  - 속도와 크기에 따라 분류한 것으로, 일반적으로 L1 캐시부터 먼저 사용됨. (CPU에서 가장 빠르게 접근하고, 여기서 데이터 못찾으면 L2로 감) 
  - L1 : CPU 내부에 존재 
  - L2 : CPU와 RAM사이에 존재 
  - L3 : 보통 메인보드에 존재한다고 함 
- 디스크 캐시 : 주기억장치(RAM)와 보조기억장치(하드디스크) 사이에 존재하는 캐시
- 듀얼 코어 프로세서의 캐시 메모리 : 각 코어마다 독립된 L1 캐시 메모리를 가지고, 두 코어가 공유하는 L2 캐시 메모리가 내장됨 
- 만약 L1 캐시 = 128kb면, 64/64로 나눠서 64kb에 명령어 처리하기 직전의 명령어 임시 저장하고, 64kb에 실행 후 명령어를 임시 저장함. (명령어 세트로 구성, I-Cache - D-Cache)

## 캐시 메모리 작동 원리 
- **시간 지역성**    
  for나 while 같은 반복문에 사용하는 조건 변수처럼 한번 참조된 데이터는 잠시후 또 참조될 가능성이 높다
- **공간 지역성**    
  A[0], A[1]과 같은 연속 접근 시, 참조된 데이터 근처에 있는 데이터가 잠시후 사용될 가능성이 높다. 참조 지역성. 
- 캐시에 데이터를 저장할 때는, 이러한 참조 지역성(공간)을 최대한 활용하기 위해 해당 데이터 뿐만 아니라, 옆 주소의 데이터도 같이 가져와 미래에 쓰일 것을 대비한다. 
- CPU가 요청한 데이터가 캐시에 있으면 'Cache Hit', 없어서 DRAM에서 가져오면 'Cache Miss'

## 캐시 미스 경우 3가지 
- **1. Cold miss** : 해당 메모리 주소를 처음 불러서 나는 미스 
- **2. Conflict miss** : 캐시 메모리에 A와 B데이터를 지정해야하는데, A와 B가 같은 캐시 메모리 주소에 할당되어있어서 생기는 미스 (direct mapped cache에서 많이 발생) 
  - 항상 핸드폰과 열쇠를 오른쪽 주머니에 넣고 다니는데, 잠깐 친구가 준 물건을 받느라 손에 들고있던 핸드폰을 가방에 넣었음. 그 이후 핸드폰을 찾으려 오른쪽 주머니에서 찾는데 없는 상황 
- **3. Capacity miss** : 캐시 메모리 공간 부족 (Conflict는 주소할당 문제, Capacity는 공간 문제)
  - 캐시 크기를 키워서 문제를 해결하려 하면, 캐시 접근속도가 느려지고 파워를 많이 먹는 단점이 생김. 

## 구조 및 작동 방식 
### Direct Mapped Cache 
  ![image](https://user-images.githubusercontent.com/29423260/172733981-661b026b-3608-40c8-93df-fec0c5754111.png)
- 가장 기본적인 구조로, DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응되는 '다대일' 방식 
- 현재 그림에서는 메모리 공간이 32개(00000~11111)이고, 캐시 메모리 공간은 8개(000~111)인 상황
  - 00000, 01000, 10000, 11000인 메모리 주소는 000 캐시 메모리 주소에 맵핑 
  - 이때 000이 '인덱스 필드', 인덱스 제외한 앞의 나머지(00, 01, 10, 11)을 '태그필드'라고 함 
  - 이처럼 캐시 메모리는 `인덱스 필드 + 태그 필드 + 데이터 필드` 로 구성된다. 
  - 장점) 간단하고 빠름 단점) **Conflict Miss가 발생**. 같은 색깔의 데이터를 동시에 사용해야 할 때 발생. 
 
### Fully Associative Cache 
- 비어있는 캐시 메모리가 있으면, 마음대로 주소를 저장하는 방식 
- 저장할 때는 매우 간단하지만, 찾을 때가 문제 
- 조건이나 규칙이 없어서 특정 캐시 set 안에 있는 모든 블럭을 한번에 찾아 원하는 데이터가 있는지 검색해야. CAM이라는 특수한 메모리 구조를 사용해야하지만 가격이 매우 비쌈. 

### Set Associative Cache 
- Direct + Fully 
- 특정 행을 지정하고, 그 행안의 어떤 열이든 비어있을 때 저장하는 방식. 
- Direct에 비해 검색 속도는 느리지만, 저장이 빠르고 Fully에 비해 저장이 느린 내신 검색이 빠른 중간형 

---

# 고정 소수점 & 부동 소수점 
## 고정 소수점 (Fixed Point) 
- 소수점이 찍힐 위치를 미리 정해놓고 소수를 표현하는 방식 ( 정수 + 소수)
- 구성 : -3.141592는 부호(-)와 정수부(3), 소수부(0.141592) 3가지 요소 필요함
  ![image](https://user-images.githubusercontent.com/29423260/172736051-948aaa16-32fc-4007-a415-eb34b1da08f1.png)
- 장점 : 실수를 정수부와 소수부로 표현하여 단순함 
- 단점 : 표현의 범위가 너무 적어서 활용하기 힘들다 ( 정수부는 15비트, 소수부는 16비트) 

## 부동 소수점(Floating Point) 
- 실수를 가수부 + 지수부로 표현한다. 
  - 가수 : 실수의 실제값 표현 
  - 지수 : 크기를 표현. 가수의 어디쯤에 소수점이 있는지 나타냄 
- 지수의 값에 따라 소수점이 움직이는 방식을 활용한 실수 표현 방법 
- 즉, 소수점의 위치가 고정되어있지 않음 
  ![image](https://user-images.githubusercontent.com/29423260/172736333-fd344772-d148-4660-a7be-a35834091f81.png)
- 장점 : 표현할 수 있는 수의 범위가 넓어진다. (현재 대부분 시스템에서 활용중) 
- 단점 : 오차가 발생할 수 있다. (부동소수점으로 표현할 수 있는 방법이 매우 다양함) 

---

# 패리티 비트 & 해밍 코드 
## 패리티 비트 
- 정보 전달 과정에서 오류가 생겼는지 검사하기 위해 추가하는 비트
- 전송하고자 하는 데이터의 각 문자에 1비트를 더하여 전송한다. 
- 종류 : 짝수 홀수 
  - 전체 비트에서 짝수/홀수에 맞도록 비트를 정하는 것 
- 짝수 패리티일때 7비트 데이터가 1010001이라면 
  - 1이 총 3개이므로, 짝수로 맞춰주기 위해 1을 더해야함. => 11010001 (맨 앞이 패리티비트) 

## 해밍 코드 
- 데이터 전송 시 1비트의 에러를 정정할 수 있는 자기 오류 정정 코드 
- 패리티비트를 보고 1비트에 대한 오류를 정정할 곳을 찾아 수정할 수 있다. (패리티비트는 오류를 검출할 뿐 수정하지는 않기 때문에 해밍 코드 활용)
- 방법 : 2의 n승 번째 자리인 1, 2, 4번째 자릿수가 패리티비트라는 것으로부터 시작함. 이 숫자로부터 시작하는 세개의 패리티 비트가 짝수인지. 홀수인지 기준으로 판별 
- 짝수 패리티의 해밍코드가 0011011일떄 오류가 수정된 코드는? 
  - 1) '1', 3, 5, 7번째 비트 확인 0 1 0 1로 짝수이므로 0 
  - 2) '2', 3, 6, 7번째 비트 확인 0 1 1 1로 홀수이므로 1
  - 3) '4', 5, 6, 7번째 비트 확인 1 0 1 1로 홀수이므로 1 
  - 역순으로 패리티비트 '110'을 도출. 10진법으로 바꾸면 `1*4+1*2+0*1 = 6`으로 6번째 비트를 수정하면 된다. 
  - 따라서 정답은 00110'0'1이다 

---

# ARM 프로세서 
## ARM : Advanced RISC Machine 
- 프로세서란 : 메모리에 저장된 명령어들을 실행하는 유한 상태 오토마톤
- ARM : `진보된 RISC기기`의 약자로 ARM의 핵심은 RISC이다. 
- RISC : Reduced Instruction Set Computing (감소된 명령 집합 컴퓨팅) 
- 단순한 명령 집합을 가진 프로세서가 복잡한 명령 집합을 가진 프로세서보다 훨씬 효율적이지 않을까? 로 탄생함 

## ARM 구조 
- ARM은 칩의 기본 설계 구조만 만들고, 실제 기능 추가와 최적화 부분은 개별 반도체 제조사의 영역으로 맡긴다. 따라서 물리적 설계는 같아도, 명령 집합이 모두 다르기 때문에 서로 다른 칩이 되기도 하는 것이 ARM 
- 소비자에게는 칩이 논리적 구조인 명령 집합으로 구성되면서, 이런 특성 때문에 물리적 설계 베이스는 같아도 용도에 따라 다양한 제품군 
- 아키텍쳐는 논리적인 명령 집합을 물리적으로 표현한 것이므로, 명령어가 많고 복잡해질 수록 실제 물리적 칩 구조도 복잡해짐 
- 하지만, ARM은 RISC 설계 기반으로 `단순한 명령집합을 가진 프로세서가 복잡한 것보다 효율적`임을 기반하기 때문에, 명령 집합과 구조 자체가 단순. 따라서 ARM 기반 프로세서가 더 작고 효율적이며 상대적으로 느림.
- 단순한 명령 집합은, 적은 수의 *트랜지스터*만 필요하므로, 간결한 설계와 더 작은 크기가 가능해짐. 반보체 기본 부품인 트랜지스터는 전원을 소비해 다이의 크기를 증가시키기 때문에 스마트폰을 위한 프로세서에는 가능한 적은 트랜지스터를 가진 것이 이상적.
- 따라서 명령 집합의 수가 적기 때문에 = 트랜지스터 수가 적고 = 크기가 작고 전원 소모가 낮은 ARM CPU가 스마트폰 같은 모바일 기기에 많이 사용된다. 

## ARM 장점
- 소비자에게 ARM은 하나의 생태계 : ARM을 위해 개발된 프로세서는 오직 ARM 프로세서가 탑재된 기기에서만 실행 
  - x86 CPU 프로세서 기반 프로그램에서는 ARM 기반 기기에서 실행할 수 없음 
- 하지만. 하나의 ARM 기기에 동작하는 OS는 다른 ARM 기반 기기에서도 잘 동작한다 : 이 장점 덕분에 수많은 버전의 안드로이드가 탄생하고 있으며, HP나 블랙베리 태블릿에도 안드로이드 탑재될 수 있는 가능성이 생김 
- ARM을 만드는 기업들은 전력 소모를 줄이고 성능을 높이기 위해 설계를 개선하는 등 노력하고 있음 
